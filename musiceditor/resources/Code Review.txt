Code Review

	The providers gave us their ImmutableMusicEditorModel interface and their views.  Using the Adapter design pattern, implementing their code was rather easy.  However, in general, the methods involving the pitchNumber were unclear.  It wasn't until we wrote more code that we realized what exactly they meant by pitchNumber.  Since Pitch is an enum and therefore has a number value, we assumed this was the pitchNumber; it was actually the Midi Note value.  In their README, they said that their Note had a pitch, octave, NoteType, instrument, and volume, but when we created the Note class based off of their MidiView code (starting at line 215), the constructor actually took in a beat, pitchNumber, NoteType, instrument, and volume.  In the MidiView, they don't use getters on the Notes, which implies that their Note fields are public.  

	There were multiple functionalities that we were unable to implement.  First, we couldn't pause the piece because our providers' MidiGuiView code did not contain any methods relating to pausing.  We were not able to change this because we would have needed to add methods inside of their View code.  For example, we would have needed to stop and restart the Sequencer, but there are no methods that do so or give us access to the Sequencer.  Second, we could not scroll.  Our providers' code did contain scrolling methods; however, our scrolling worked without adding a runnable to createKeyboardHandler.  In order to implement scrolling we would have had to change our Controller.  Lastly, we could not implement adding or removing notes.  We removed notes by clicking on their start beats, but our providers used a textbox.  In order to implement removing notes, our providers would have needed to give us access to their display panel (in ConcreteGuiViewPanel) and we would need to focus our mouse on the display panel as it currently only registered on the top area that contained the "enter" button.  We asked our providers to refractor their code, but they were unable to due to time constraints.  We add notes using a pop-up textbox and the "enter" key (which is what processes the input and adds the note), but our providers' code uses a textbox and "enter" button.  The issue was that once we added information into the textbox, there was no way for us to set the focus back to the keyboard.  The only way to fix the above issues would be for our providers to refractor their code and for us to override and rewrite our createKeyBoardHandler and createMouseHandler methods.

	The last issue was that the visual view was zoomed in.  This affected jumping to the beginning and end of the music.  The providers hard coded values instead of creating static constants that we could change to make the code work on our laptops.  They refractored their code and we were able to change the constants found in their ConcreteGuiPanel.  However, the MidiGuiView still stops playing one note short, when you jump to the beginning of the music after jumping to the end the red line doesn't move (and the music still plays), and the red line and the notes on the last beat disappear when you jump to the end.  We know that these issues are caused by their code as everything renders correctly and the only code in their GuiView Interface that deals with jumping is jumpToBegin and jumpToEnd. These are the methods we call in the GuiViewAdapter.

	In general, we would suggest less hard coding and less dependency on the specifics of a music piece.  For example, some of their code is dependent on the model's tempo, therefore changing the tempo affects functionality such as jumping to the end of the piece.